#include "BluetoothA2DPSink.h" // Incluimos todas las librerias necesarias. 
#include <SPI.h>               // Usamos 4-Wire SPI porque la SH no tiene I2C.
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SH110X.h>
#include "AiEsp32RotaryEncoder.h"
#include "Arduino.h"


#define OLED_MOSI     23 // (SDA (D1)) va al GPIO MOSI
#define OLED_CLK      18 // SCK GPIO
#define OLED_RST      17 // TX2 GPIO
#define OLED_DC       16 // RX2 GPIO
#define OLED_CS       5  // SS  GPIO

// setup luces con pwm fade

#define R 15 // GPIO 15, 2, 4
#define G 2
#define B 4

int brillo = 0 ; int fade = 5;

// Setup de codificador rotativo

#define ROTARY_ENCODER_A_PIN 14 // HSPI CLK GPIO para evitar conflicto con OLED
#define ROTARY_ENCODER_B_PIN 22
#define ROTARY_ENCODER_BUTTON_PIN 21
#define ROTARY_ENCODER_VCC_PIN -1 // va al 3.3 de la placa
#define ROTARY_ENCODER_STEPS 4

AiEsp32RotaryEncoder rotaryEncoder = AiEsp32RotaryEncoder(ROTARY_ENCODER_A_PIN, ROTARY_ENCODER_B_PIN, ROTARY_ENCODER_BUTTON_PIN, ROTARY_ENCODER_VCC_PIN, ROTARY_ENCODER_STEPS);

void rotary_onButtonClick()
{
    static unsigned long lastTimePressed = 0; // Soft debouncing
    if (millis() - lastTimePressed < 500)
    {
            return;
    }
    lastTimePressed = millis();
    Serial.print("button pressed ");
    Serial.print(millis());
    Serial.println(" milliseconds after restart");
}

void rotary_loop()
{
    //dont print anything unless value changed
    if (rotaryEncoder.encoderChanged())
    {
            Serial.print("Value: ");
            Serial.println(rotaryEncoder.readEncoder());
            delay(50);
    }
    if (rotaryEncoder.isEncoderButtonClicked())
    {
            rotary_onButtonClick();
    }
}

void IRAM_ATTR readEncoderISR()
{
    rotaryEncoder.readEncoder_ISR();
}

/*
Conexiones JOYSTICK
GND - GND
Vcc - 5v (Puede funcionar con 3.3V)
VRx - A0: Canal 0 del ADC // ADC1_6
VRy - A1: Canal 1 del ADC // ADC1_7
SW  - D9                  // TX0
*/

#define JX     35 //vrx --> adc1_6
#define JY     34 //vry --> adc1_7
#define JB     21 //tx0 --> pullup (valor 0,1);

#define LEDB   19 //led emparejamiento
#define LEDG   21


bool isPlaying = true; // para control de canción pause/stop.

String songTitle;
String artistName;
String albumName;

/*
  Pantalla --> 0x3F  
*/

// Inicia la pantalla

Adafruit_SH1106G display = Adafruit_SH1106G(128, 64,OLED_MOSI, OLED_CLK, OLED_DC, OLED_RST, OLED_CS);

// Función para obtener metadata. Se puede ampliar

 void avrc_metadata_callback(uint8_t id, const uint8_t *text) {
    switch (id) {
        case ESP_AVRC_MD_ATTR_TITLE:
           songTitle = (char*) text;
            break;
        case ESP_AVRC_MD_ATTR_ARTIST:
            artistName = (char*) text;
            break;
        case ESP_AVRC_MD_ATTR_ALBUM:
            albumName = (char*) text;
            break;    
    } 
    /*Serial.println( songTitle);
    Serial.println(artistName);*/
}

const unsigned char esp32bt [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xe3, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xe3, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x38, 0x40, 0x0c, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x38, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x07, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x07, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x02, 0x00, 0x07, 0x80, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x87, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x70, 0x01, 0xc7, 0x8e, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x70, 0x01, 0xc0, 0x06, 0x30, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x20, 0x30, 0x08, 0x00, 0x38, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x38, 0x0e, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x30, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x03, 0x00, 0x00, 0x0f, 0xc0, 0x01, 0x83, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x03, 0x87, 0x00, 0x0f, 0xe0, 0x01, 0xc3, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x03, 0x07, 0x00, 0x0c, 0x78, 0x01, 0x83, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x03, 0x00, 0x0e, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0c, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x08, 0x00, 0x00, 0x0c, 0x07, 0xc0, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x1c, 0x30, 0x40, 0x0c, 0x01, 0xe0, 0x38, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x1c, 0x38, 0xe0, 0x0c, 0x00, 0xf8, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x30, 0xf8, 0x0c, 0x00, 0x7c, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x3c, 0x0c, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x1f, 0x0c, 0x01, 0xe0, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x10, 0x00, 0x07, 0x8c, 0x07, 0xc0, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x38, 0xe0, 0x01, 0xec, 0x0f, 0x00, 0x06, 0x70, 0x3e, 0x7f, 0x00, 0x7f, 0x3e, 0xf8, 0xfc, 0x78, 
	0x38, 0xe0, 0x00, 0xfc, 0x3e, 0x00, 0x00, 0x70, 0x21, 0x08, 0x00, 0x40, 0x00, 0x80, 0x08, 0x00, 
	0x00, 0x40, 0x00, 0x3c, 0x78, 0x00, 0x00, 0x20, 0x21, 0x08, 0x00, 0x40, 0xc0, 0x82, 0x08, 0x84, 
	0x00, 0x00, 0x00, 0x1f, 0xe0, 0x00, 0x00, 0x00, 0x21, 0x08, 0x00, 0x40, 0xc0, 0x82, 0x10, 0x04, 
	0x00, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x02, 0x00, 0x3e, 0x08, 0x7f, 0x7c, 0x3c, 0xf8, 0x08, 0x08, 
	0x10, 0x00, 0x00, 0x0f, 0xc0, 0x00, 0x07, 0x00, 0x21, 0x08, 0x00, 0x40, 0x02, 0x80, 0x00, 0x10, 
	0x38, 0xe0, 0x00, 0x1e, 0xf0, 0x00, 0x07, 0x70, 0x21, 0x08, 0x00, 0x40, 0x02, 0x80, 0x04, 0x00, 
	0x38, 0xe0, 0x00, 0x7c, 0x78, 0x00, 0x00, 0x70, 0x21, 0x08, 0x00, 0x40, 0x02, 0x80, 0x84, 0x40, 
	0x00, 0x40, 0x01, 0xfc, 0x1e, 0x00, 0x00, 0x20, 0x3e, 0x08, 0x00, 0x7f, 0xfc, 0x80, 0x78, 0xfc, 
	0x00, 0x00, 0x03, 0xcc, 0x0f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x0f, 0x8c, 0x03, 0xc0, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x0c, 0x00, 0x1e, 0x0c, 0x01, 0xf0, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x1c, 0x30, 0x7c, 0x0c, 0x00, 0x78, 0x0c, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x1c, 0x30, 0xf0, 0x0c, 0x00, 0x7c, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0xe0, 0x0c, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0c, 0x03, 0xe0, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0c, 0x07, 0x80, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x07, 0x06, 0x00, 0x0c, 0x1e, 0x00, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x07, 0x07, 0x00, 0x0c, 0x3c, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x02, 0x02, 0x00, 0x0c, 0xf0, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0f, 0xe0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x70, 0x0f, 0x80, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x60, 0x70, 0x0f, 0x00, 0x02, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x60, 0x20, 0x0c, 0x00, 0xc0, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x60, 0x01, 0x88, 0x00, 0xe0, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0x86, 0x38, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x06, 0x01, 0x0e, 0x38, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x07, 0x00, 0x06, 0x18, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x06, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x30, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x38, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x30, 0xc0, 0x08, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x01, 0xc3, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xc7, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


BluetoothA2DPSink a2dp_sink;

void setup() {

  // inicializa el encoder

    rotaryEncoder.begin();
    rotaryEncoder.setup(readEncoderISR);
    //set boundaries and if values should cycle or not
    //in this example we will set possible values between 0 and 1000;
    bool circleValues = false;
    rotaryEncoder.setBoundaries(0, 1000, circleValues); //minValue, maxValue, circleValues true|false (when max go to min and vice versa)

    /*Rotary acceleration introduced 25.2.2021.
   * in case range to select is huge, for example - select a value between 0 and 1000 and we want 785
   * without accelerateion you need long time to get to that number
   * Using acceleration, faster you turn, faster will the value raise.
   * For fine tuning slow down.
   */
    //rotaryEncoder.disableAcceleration(); //acceleration is now enabled by default - disable if you dont need it
    rotaryEncoder.setAcceleration(150); //or set the value - larger number = more accelearation; 0 or 1 means disabled acceleration

  pinMode(LED_BUILTIN, OUTPUT);
  pinMode(R, OUTPUT); pinMode(G, OUTPUT); pinMode(B, OUTPUT);

  pinMode(JB, INPUT_PULLUP);  //activar resistencia pull up  
  pinMode(JX, INPUT_PULLUP);
  pinMode(JY, INPUT_PULLUP);

  Serial.begin(115200);


  // Inicia OLED

  display.begin(0,true); // reset sin I2C

  // Splashcreen Adafruit por estética

  display.display(); delay(1000); display.clearDisplay();

  display.drawBitmap(0, 0, esp32bt, 128, 64, 1); display.display(); delay(2500); display.clearDisplay();

  // configuramos i2s del dac

    i2s_pin_config_t my_pin_config = {
        .bck_io_num = 27, //// BCLK 
        .ws_io_num = 26,  //// LRC pin 
        .data_out_num = 25, ///Din pin
        .data_in_num = I2S_PIN_NO_CHANGE
    };

    a2dp_sink.set_pin_config(my_pin_config);
    a2dp_sink.start("ESP32a2dp_guts");
    a2dp_sink.set_avrc_metadata_callback(avrc_metadata_callback);
    a2dp_sink.set_avrc_metadata_attribute_mask(ESP_AVRC_MD_ATTR_TITLE | ESP_AVRC_MD_ATTR_ARTIST | ESP_AVRC_MD_ATTR_ALBUM);
  

    static const i2s_config_t i2s_config = {
        .mode = (i2s_mode_t) (I2S_MODE_MASTER | I2S_MODE_TX | I2S_MODE_DAC_BUILT_IN),
        .sample_rate = 44100, // corrected by info from bluetooth
        .bits_per_sample = (i2s_bits_per_sample_t) 16, /* the DAC module will only take the 8bits from MSB */
        .channel_format = I2S_CHANNEL_FMT_RIGHT_LEFT,
        .communication_format = (i2s_comm_format_t)I2S_COMM_FORMAT_STAND_MSB,
        .intr_alloc_flags = 0, // default interrupt priority
        .dma_buf_count = 8,
        .dma_buf_len = 64,
        .use_apll = false
    };

    //a2dp_sink.set_i2s_config(i2s_config);

  // Bienvenida a BT.
    analogWrite(B, 200); // luz

    display.setTextSize(1);
    display.setTextColor(SH110X_WHITE);
    display.setCursor(0, 0);
    display.println("Iniciando ESP32...");
    display.println("Iniciando altavoz BT...");
    display.display(); 
    delay(2000); 
    display.clearDisplay();
    display.setCursor(0,0);
    display.println("Dispositivo BT activado"); digitalWrite(B, LOW);
    display.setCursor(0,24);
    display.println("Listo para emparejar."); 
    display.display();
    analogWrite(B, 0);

    while (a2dp_sink.is_connected() == false){  // parpadeo emparejamiento

      digitalWrite(R, HIGH);
      delay(500);
      digitalWrite(R, LOW);
      delay(500);

    }
     
}

void loop() {


    int vol = rotaryEncoder.readEncoder(); // Asignamos valor a la lectura.

    if (rotaryEncoder.readEncoder() > 100){

          vol = 100; // Obviamente no vamos a hacer un display de 200% en el volumen. Esto limita el integer a 100.

        }

        else {

          vol = rotaryEncoder.readEncoder(); // Vuelta a lo normal.

        }

// Check conectividad a BT.

    if (a2dp_sink.is_connected() == true) {

      // digitalWrite(G,HIGH);

      digitalWrite(R, 0); digitalWrite(G, 0); analogWrite(G, brillo); 

        // change the brightness for next time through the loop:
      brillo = brillo + fade;

        // reverse the direction of the fading at the ends of the fade:
      if (brillo <= 0 || brillo >= 255) {
         fade = -fade;
       }
        // wait for 30 milliseconds to see the dimming effect
      delay(30);
      
      display.clearDisplay();
      display.setTextSize(1);
      
      display.clearDisplay();
      display.setCursor(35,0); // Centrado. Valores en pantalla --> (x,y)
      display.setTextSize(2);
      display.println("BT ON");

      display.setTextSize(1);
      display.setCursor(0,12); display.println("....................."); display.println();

      display.setCursor(0,20);
      display.print("Volumen: ");
      display.print(vol); 
      
      if (rotaryEncoder.readEncoder() > 102) {
        
        display.println("% (+)"); // mostramos valor mayor del recomendado.
      
      }

      else{

        display.println("%");

      }

      display.println();  

      display.print("Cancion: ");
      display.println(songTitle);
      

      display.print("Artista: ");
      display.println(artistName);
      display.println();

      /*display.print("Album: ");
      display.println(albumName);*/

      display.display();

    // defino valores iniciales joystick

     int pos_x = 0;
     int pos_y = 0;
     bool boton = false;
     
     // Lectura del joystick
     pos_x = analogRead(JX);
     delay(20);            // pausa entre lecturas analógicas (necesaria)
     pos_y = analogRead(JY);
     boton = digitalRead(JB);
	   //digitalWrite(LED, JB); // controla el led con el estado del botón

     if (pos_x > 3000){

        a2dp_sink.next();
        delay(500);
        //break;
        
     }
     if (pos_x < 2500) {

        a2dp_sink.previous();
       delay(500);
       //break;

     }

     if (boton == LOW) {

        if (isPlaying == true){
        a2dp_sink.pause();
        
      
      }

      else{

       a2dp_sink.play();

      }
      
     }

    rotary_loop(); // loop para el codificador. constantemente actualizamos posición y volúmen.

      a2dp_sink.set_volume(rotaryEncoder.readEncoder());
      delay(50);   

    delay(50);

    }

    else {

      analogWrite(G, 0); 

      display.clearDisplay();

      display.clearDisplay();
      display.setCursor(35,0); // Centrado. Valores en pantalla --> (x,y)
      display.setTextSize(2);
      display.println("BT OFF");



    }


}